// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2084.CMonster.commands;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.Utility;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc2084.CMonster.Robot;
import org.usfirst.frc2084.CMonster.RobotMap;

/**
 *
 */
public class ManualClimbMotorControl extends Command {

    private static final double // Arm software stop constants
            TOP_HIGH_LIMIT = 300, // Need real value
            TOP_LOW_LIMIT = 0, // Need real value
            BOTTOM_HIGH_LIMIT = 0, // Need real value
            BOTTOM_LOW_LIMIT = 0, // Need real value
            // Acceleration filter constants
            SAFETY_TIME_THRESHHOLD = 0.1, // See below
            SAFETY_INCREASE_LIMIT = 0.3, // Maximium the speed can increase every RAMP_TIME_THRESHHOLD seconds
            SAFETY_RESET_THRESHOLD = 0.05; // The threshold at which the safety resets

    public ManualClimbMotorControl() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        requires(Robot.driveBaseSubsystem);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.climbingSubsystem);
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
        lastTime = Timer.getFPGATimestamp();
    }
    private double lastTime;
    private double lastLeftValue;
    private double lastRightValue;
    private boolean topSafetyTriggered;
    private boolean bottomSafetyTriggered;

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        SmartDashboard.putNumber("Potentiometer value", RobotMap.climbingSubsystemTopPotentiometer.getVoltage());
        SmartDashboard.putNumber("Potentiometer degrees", Robot.climbingSubsystem.getTopPotDegrees());
        double leftJoy = Robot.oi.getLeftJoystick().getY();
        double topSpeed = leftJoy;
        double rightJoy = Robot.oi.getRightJoystick().getY();
        double bottomSpeed = rightJoy;
        double topPot = Robot.climbingSubsystem.getTopPotDegrees();
        double bottomPot = Robot.climbingSubsystem.getBottomPotDegrees();
        double currTime = Timer.getFPGATimestamp();
        //Add code to control arm here (commented out for now with no pots)
//        if ((topPot < TOP_LOW_LIMIT && leftJoy < 0) || (topPot > TOP_HIGH_LIMIT && leftJoy > 0)) {
//            topSpeed = 0;
//        }
//if ((bottomPot < BOTTOM_LOW_LIMIT && rightJoy < 0) || (bottomPot > BOTTOM_HIGH_LIMIT && rightJoy > 0)) {
//            bottomSpeed = 0;
//        }
        boolean justTriggeredTop = false;
        boolean justTriggeredBottom = false;
        if (currTime - lastTime > SAFETY_TIME_THRESHHOLD) {
            if (Math.abs(rightJoy) > Math.abs(lastRightValue) + SAFETY_INCREASE_LIMIT) {
                bottomSpeed = 0;
                bottomSafetyTriggered = true;
                justTriggeredBottom = true;
            }
            if (Math.abs(leftJoy) > Math.abs(lastLeftValue) + SAFETY_INCREASE_LIMIT) {
                topSpeed = 0;
                topSafetyTriggered = true;
                justTriggeredTop = true;
            }
            lastLeftValue = leftJoy;
            lastRightValue = rightJoy;
            lastTime = currTime;
        }
        if (topSafetyTriggered && !justTriggeredTop) {
            if (Math.abs(leftJoy) >= SAFETY_RESET_THRESHOLD) {
                topSpeed = 0;
            } else {
                topSafetyTriggered = false;
            }
        }
        if (bottomSafetyTriggered && !justTriggeredBottom) {
            if (Math.abs(rightJoy) >= SAFETY_RESET_THRESHOLD) {
                bottomSpeed = 0;
            } else {
                bottomSafetyTriggered = false;
            }
        }

        RobotMap.climbingSubsystemBottomJaguar.set(bottomSpeed);
        RobotMap.climbingSubsystemTopJaguar.set(topSpeed);
    }
// Make this return true when this Command no longer needs to run execute()

    protected boolean isFinished() {
        return !(Robot.oi.rightClimbMotorControlButton.get() || Robot.oi.leftClimbMotorControlButton.get() || Robot.climbingSubsystem.climbingModeEnabled);
    }
    // Called once after isFinished returns true

    protected void end() {
        RobotMap.climbingSubsystemBottomJaguar.set(0);
        RobotMap.climbingSubsystemTopJaguar.set(0);
    }
    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run

    protected void interrupted() {
        end();
    }
}
