// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2084.CMonster.commands;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc2084.CMonster.Robot;
import org.usfirst.frc2084.CMonster.RobotMap;
/**
 *
 */
public class DriveUntilSmashCommand extends Command {
    // Constants for adjusting the behavior of the autonomous mode
    private static final double ULTRASONIC_LOW_THESHHOLD = 3.0;
    private static final double ULTRASONIC_HIGH_THRESHHOLD = 20.0;
    private static final double MAX_SPEED = 1.0;
    private static final double MIN_SPEED = 0.1;
    private static final double EXTRA_TIME = 0.5;
    private static final double ACCEL_TIME = 0.01;
    private static final double ACCEL_INCREMENT = 0.01;
    
    private double extraTimer = -2.0;
    private double extraTimerStart;
    private double accelLastTime = 0.0;
    private double accelCurrSpeed = 0.0;
    private int[] ultrasonicBuffer = new int[10];
    int averageUltrasonic = 0;
    public DriveUntilSmashCommand() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        requires(Robot.climbingSubsystem);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveBaseSubsystem);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }
    // Called just before this Command runs the first time
    protected void initialize() {
        accelLastTime = Timer.getFPGATimestamp();
    }
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        if (extraTimer == -1.0) {
            int newVal = Robot.driveBaseSubsystem.getUltrasonicDistance();
            int sum = newVal;
            for (int i = 1; i < ultrasonicBuffer.length; i++) {
                sum += ultrasonicBuffer[i];
                ultrasonicBuffer[i - 1] = ultrasonicBuffer[i];
            }
            ultrasonicBuffer[ultrasonicBuffer.length - 1] = newVal;
            averageUltrasonic = sum / ultrasonicBuffer.length;
            if (averageUltrasonic > ULTRASONIC_HIGH_THRESHHOLD) {
                RobotMap.driveBaseSubsystemRobotDrive.drive(MAX_SPEED, 0.0);
            } else {
                double driveCoefficient = averageUltrasonic / ULTRASONIC_HIGH_THRESHHOLD;
                double driveSpeed = (MAX_SPEED - MIN_SPEED) * driveCoefficient + MIN_SPEED;
                RobotMap.driveBaseSubsystemRobotDrive.drive(driveSpeed, 0.0);
            }
        } else if (extraTimer == -2.0) {
            if (Timer.getFPGATimestamp() - accelLastTime > ACCEL_TIME) {
                if (accelCurrSpeed < MAX_SPEED) {
                    accelCurrSpeed += ACCEL_INCREMENT;
                    RobotMap.driveBaseSubsystemRobotDrive.drive(accelCurrSpeed, 0.0);
                } else {
                    extraTimer = -1.0;
                }
            }
        } else {
            extraTimer = Timer.getFPGATimestamp();
            RobotMap.driveBaseSubsystemRobotDrive.drive(MIN_SPEED, 0.0);
        }
    }
    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        if (averageUltrasonic < ULTRASONIC_LOW_THESHHOLD) {
            extraTimer = 0.0;
            extraTimerStart = Timer.getFPGATimestamp();
        } else if (extraTimer - extraTimerStart > EXTRA_TIME) {
            return true;
        }
        return false;
    }
    // Called once after isFinished returns true
    protected void end() {
        RobotMap.driveBaseSubsystemRobotDrive.drive(0.0, 0.0);
    }
    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
        end();
    }
}
